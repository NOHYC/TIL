# 0415



## 1. 연산자

- 연산자 우선 순위

  | 순위 | 연산자                                                       | 결합순서    |
  | ---- | ------------------------------------------------------------ | ----------- |
  | 1    | ( ) , [ ] ,  .  ,  -> ,  ++ (후위) , -- (후위)               | 왼쪽우선    |
  | 2    | ++ ( 전위 ), -- ( 전위 ) , sizeof, ~ ( 비트 ), ! ( 비트 ) , - (부호) , + (부호) , & (주소) , * (간접참조) | 오른쪽 우선 |
  | 3    | * ( 곱하기 ) , / (나누기 ) , % (나머지)                      | 왼쪽 우선   |
  | 4    | + (더하기), - (빼기 )                                        | 왼쪽 우선   |
  | 5    | <<  (비트) , >> (비트)                                       | 왼쪽우선    |
  | 6    | < , <= , > , >=                                              | 왼쪽우선    |
  | 7    | == , !=                                                      | 왼쪽우선    |
  | 8    | & (비트)                                                     | 왼쪽우선    |
  | 9    | ^ (비트)                                                     | 왼쪽우선    |
  | 10   | \| (비트)                                                    | 왼쪽우선    |
  | 11   | && (논리)                                                    | 왼쪽우선    |
  | 12   | \|\| (논리)                                                  | 왼쪽우선    |
  | 13   | ? :                                                          | 오른쪽우선  |
  | 14   | =                                                            | 오른쪽우선  |
  | 15   | ,                                                            | 왼쪽우선    |



- 고려해야할 점
  1. sizeof : 64 bit 컴파일러에서 포인터는 8 byte, 32 bit 컴파일러에서 포인터 4 byte
  2. 삼항 조건 연산자란? 조건식 ? ( 참일 때 실행 문장 ) : 거짓일 때 실행 문장 
     - 파이썬에서 where() 함수와 같은 기능
  3. 비트 연산에서 쉬프트 연산자 쓸 때 주의할 점
     - unsigned 타입 데이터 >> 할 때 상위 비트들에 0 padding
     - unsigned 타입 데이터 << 할 때 하위 비트들에 0 padding
     - signed 타입 데이터 >> 할 때 (MSB가 1일 경우) 1 padding
     - signed 타입 데이터 << 할 때 하위 비트들 0 padding
  4. \* ( 간접 참조 연산자 ) : 메모리 상의 주소에 접근하여 데이터를 읽거나 쓴다.
  5. \[ \] 연산자는 \[ \] 안의 값만큼 포인터 덧셈 ( 간접 참조 연산자와 동일한 취급 )



- 형 변환 ( Type casting ) 
  - C 언어는 항상 같은 타입 연산만 가능 -> 다른 타입과 연산 시 **묵시적 형 변환과 명시적 형변환** 됨
  - 정수의 승격 
    - unsigend 타입은 데이터 확장 시 0 padding
      - usigned char c = 0x28 ( 0010 1000 ) , ( n = c ) , unsigned int a = 0x28 ( 0000 0000 0000 000 0000 0000 0010 1000)
    - signed 타입 데이터 확장 시 signed bit expansion 
      - signed char c = 0xA8 ( 1010 1000 ) , ( a= c ) , signed int a = ffffffA8 ( 1111 1111 1111 1111 1111 111 1010 1000)
- short circuit evalution 
  - 논리 연산의 특징에 따라 수식이 평가되거나 무시
    - and : 왼쪽이 거짓이면 오른쪽도 거짓이기 때문에 평가할 필요없이 거짓 출력
    - or : 왼쪽이 참이면 왼쪽도 참이기 때문에 평가할 필요 없이 참 출력

## 2. 비트연산



### 1. 비트 셋

- 원하는 bit를 1로 set 
  - 0x3 ( 0011 ) - > 2,3번 비트를 1로 set하려면
  - 0x3 (0011) | 0xc (1100) 
  - 0x3 | 0x3 << 2 ==> 1111
  - data |= 0x3 <<2 복합 대입 연산자 사용

### 2. 비트 클리어

- 원하는 bit를 0으로 clear 
  - 0x3 ( 0011 ) -> 0,1 번 비트를 0으로 clear하려면
  - 0x3 ( 0011 ) & 0x3 ( 0011 )

### 3. 비트 반전

- 원하는 비트 반전
  - 0x3 ( 0011 ) - > 2,3 번 비트 반전
  - 0x3 ( 0011 ) ^ 0xf ( 1111 )

### 4. 연산자 활용

1. clear ( 부분 )
2. set or 반전



## 2. 배열



### 1. 배열이란

- 동일한 타입의 변수들이 메모리 상에 연속적으로 존재하고 각각의 공간에 대해 일정한 이름 규칙이 있는 것

### 2. 초기화 방법

1. int arr[2] = { 1,2 }

2. int arr[2] ;

   arr[0] = 2;

   arr[1] = 1;

3. int arr[] = { 1, 2 };

4. int arr[4] = {1,2 }; ( 나머지는 0으로 채움 )

5. int arr[6] = {0} ; ( 배열 전체를 0으로 채움 ) 

- 배열을 초기화하지 않으면 쓰레기 값이 들어있다. 그러나 전역 변수 처럼 사용할 경우 0 채움



### 3. 배열의 특징

1. 참조 연산 : 컴파일러가 구문을 해석할 때 배열의 바운더리를 검사해주지 않기 때문에 작성 시 주의해야한다. 

   ```
   char carr[2] = { 1,2};
   carr[2] = carr[0] 가능하다.
   ```

2. 코드 상에 적은 배열의 이름은 배열 첫번째 원소의 시작 주소와 완전히 동일 시 된다. 

3. 배열의 이름은 첫번째 원소 1칸을 가리키는 주소 ( 포인터 상수 )

4. 문자열은 널문자( '\0' ) 로 끝나는 문자들 1개 이상의 집합 

   char str[] = "apple" => char str[7] = { 'a'.'p','p','l','e','\0'} 



## 3. 포인터



### 1. 주소란?

- 메모리상 위치를 표현하는 데이터
- 메모리의 1 byte 단위 한 칸을 1 address 
- 주소는 그 주소로부터 몇 byte를 읽고 써야하는지 결정하기 위해 타입 존재



### 2. 포인터 개념

- 주소를 포인터라고 한다.
  - 주소( 포인터 )를 저장하는 변수를 포인터 변수라 한다.
- 변수 선언
  - ( 가리키는 타입 ) * ( 변수명 )
  - 변수 p에 n의 주소가 저장되면 p는 n을 가리킨다. 라고 표현
- 포인터 변수는 가리키는 대상의 타입도 맞추어 선언한다.
  - 포인터 변수 형변환 



### 3. 포인터 특징

- 간접 참조 연산자 ( * )는 그 주소로 가서 값을 써라 또는 그 주소로 가서 값을 읽어라는 명령으로 변환
- 포인터의 증감 연산
  - 포인터는 +, ++, - , --  연산 가능
  - 그러나 포인터 증감은 타입별로 다르다. ( char * ) : 1 , ( short * ) : 2  , ( int *) : 4 

- Call by address / pointer

  1. 주소를 함수의 인자로 전달
  2. 호출할 때 전달한 주소가 함수 진자로 복사되어 들어가는 형태
  3. 함수는 간접 참조 연산을 통해 전달 받은 주소에 접근하여 값 수정 가능

  ```c
  void main(){
      int a = 3, b = 4;
      pointer(&a,&b);
  
  }
  int pointer(int *a,int *b ){
      *a = 1;
      *b = 2;
  }
  ```



## 4. 다양한 포인터

### 1. 해석

- \[  \] : 배열 타입, *  : 포인터 타입, (  ) :함수 타입

- 컴파일러는 선언문에서 이름부터 오른쪽 방향으로 차례로 구문 해석



### 2. 포인터 배열

- int *pArr[4] : 배열 요소 각각의 *는 int를 가리키는 포인터 ( 배열 요소의 각각은 int의 주소를 저장 )

- 포인터 여러 개를 저장할 때 사용 

### 3. 배열 포인터

- int ( *pArr )[ 3 ] : pArr이 가리키는 3칸짜리 배열은 각 요소들이 int
- 2차원 배열 가리킬 때 사용
- 부분 배열

### 4. 함수 포인터

- int (* Func ) () : 인자 형태가 void인 Func함수는 리턴 타입이 int 

- 함수의 주소를 가리킬 때 사용

  ```c
  void printM(void){
      printf("good");
  }
  
  void main(){
      void (*pFunc)();
      
      pFunc = prinfM;
      (*pFunc)();
  }
  ```

- void 포인터 ( void * )

  - (int *), (char *) 와 같이 4 byte 주소 타입이나 몇 byte 액세스할지 결정하지 않은 주소 타입
  - 어떤 타입이든 가리킬 수 있음.
  - 그러나 byte 액세스 하지 않아서 증감 연산자 불가
  - 그래서 type casting해서 사용

### 5. 함수 포인터 배열

- int ( *pFunc[3] ) () : pFunc 배열의 요소인 포인터 각각이 가리키는 void 인자 모양의 함수는 리턴 타입이 int
- 배열 내에 포인터들이 함수를 가리킨다.
- 여러 개의 함수의 주소를 가리킬 때 사용.

### 6. 이중 포인터

- int **pp : 포인터 pp가 가리키는 포인터는 타입이 int 
- 포인터를 가리킨다.
- c에는 삼중 포인터까지 있다.
- \*** --> ** --> * 
- **에는 *의 주소가 들어있다.
- 다른 함수에서 *에 들어있는 값( 변수 주소)를 변경하려면 *의 주소를 전달해야 한다.



## 5. 구조체

### 1. 구조체 정의

- 메모리상에 할당되는 것이 아닌, 구조체의 모양 자체를 컴파일러에게 알려주는 것

- 구조체 정의 후, 컴파일러는 새로운 타입으로 인식

  ```c
  struct Person // 구조체 태그명
  {
      char *name; // 구조체의 멤버 선언
      double weight;
      int age;
  };
  void main(){
      struct Person me;
      // struct Person 타입의 변수 me 선언
  }
  ```



### 2. 자주 사용되는 방식

- 헤더 파일에 구조체를 정의하고, 소스파일에서 해당 구조체 타입의 변수 선언

- typedef ( 타입 재정의 )를 이용한 방법

  ```c
  // Person.h
  typedef struct Person_t
  {
      char *name;
      int age;
  } Person;
  
  // main.c
  void main(){
      Person people[123];
      // Person 타입의 123 배열 선언
  }
  ```

  